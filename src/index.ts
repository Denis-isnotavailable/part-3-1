// type DialogButtonType = "Yes" | "No";

// interface FormButton {
//     type: "Add" | "Remove" | "Buy"
// }

// // задача 1: создайте тип AnyButtonType, который описывает все вариации кнопок
// type AnyButtonType = DialogButtonType | FormButton["type"]; // только без копипасты литералов, пожалуйста

// const btn1: AnyButtonType = "Add";
// const btn2: AnyButtonType = "No";
// // const btn3: AnyButtonType = "TTTTT";

// // задача 2: создайте тип ConfirmationHandlingFormButton
// // т.е. подтип формовых кнопок, которые ещё содержат поле onConfirm, в котором
// // может лежать функция, которая вызывается с параметром типа DialogButtonType
// // (и ничего не возвращает)
// // Т.е. предполагается что у кнопки такого типа, если поле onConfirm пустое,
// // то при нажатии на эту кнопку сразу происходит действие
// // а иначе вызывается диалог Подтверждения, и результат нажатия на кнопку Да или Нет
// // в итоге попадет в функцию onConfirm, которая уже дальше решит что делать
// type ConfirmationHandlingFormButton = FormButton & {
//     onConfirm?: (button: DialogButtonType) => void;
// };

// const btn4: ConfirmationHandlingFormButton = {
//     type: "Add",
// };
// const btn5: ConfirmationHandlingFormButton = {
//     type: "Add",
//     onConfirm: (button) => {button === "Yes" ? console.log('Confirmation is positive') : console.log('Confirmation is negative');}
// };

// btn5.onConfirm && btn5.onConfirm(btn2);

////=======================================================================================================
////=======================================================================================================


// // Есть функция. Она принимает некий объект А, у которого есть поля со значениями
// // - или undefined
// // - или объекта с одним полем cvalue, который
// //      либо undefined
// //      либо по типу равный
// //           либо строке,
// //           либо числу,
// //           либо ссылке на объект по своей структуре/описанию подобный описываемому объекту А.
// // ...Функция должна вернуть сумму "значений" поля cvalue всех полей объекта, притом,
// // - если у очередного элемента поле сvalue - это число,
// //   то просто добавляем это число.
// // - если у очередного элемента поле сvalue - это строка,
// //   то просто конвертим строку в число и добавляем.
// // - если у очередного элемента поле cvalue - это объект подобный корневому,
// //   то добавляем сумму его полей (привет рекурсия)
// // - если мы натыкаемся на undefined, или же если cvalue был строкой которая по факту не являлась адекватным числом -
// //   то тогда значением будет 2022.
  
// // например, для { hello: {cvalue: 1}, world: { cvalue: { yay: { cvalue: "2" } } } }
// // должно вернуться 3

// // Скоро дадим вам функцию, но она немного багонутая.
// // Попробуйте найти в ней все баги самостоятельно без запуска этого кода.
// // Когда вы увидели все баги и готовы их исправлять, то сделайте это (НО НЕ НАДО ПЕРЕПИСЫВАТЬ С НУЛЯ :)) ),
// // и когда будете уверены что функция работает ок - можете попробовать запустить ее и потестить.
// // Перед запуском изучите, что ваш любимый редактор подсвечивает в коде.
// // Нашел ли он какие-то ошибки?
// // Если допустить, что все-таки вы пропустили ряд ошибок, то время протестировать тайпскрипт.

// // 1) сложный этап. напишите нормальную тайпскриптовую сигнатуру функции
// // (отдельно опишите тип первого аргумента в виде interface)

// // 2) если не получилось, смотрите спойлер: https://pastebin.com/2nEJvk04

// // 3) пользуясь силой тайпскрипта и описанной сигнатуры,
// // найдите как можно больше ошибок, которых не нашли раньше.
// // По мере фикса кода, обнаруживайте еще ошибки на шару в процессе кодинга,
// // без запуска программы.
// // результат скиньте @roman

// // ... а вот и код багонутой функции:

// const A = {
//     hello: { cvalue: 1 },
//     world: {
//         cvalue: {
//             yay: { cvalue: "2" },
//             // jj: {cvalue: undefined}
//         }
//     }
// };

// function summ(a: any) {
//     const x = Object.keys(a).map((k) => {
//         const elem = a[k];
        
//         if (typeof elem.cvalue === 'object') return summ(elem.cvalue);
//         else if (isNaN(elem.cvalue)) return 2022;

//         return Number(elem.cvalue);
//     });

//     let sum = 0;
    
//     for (let i = 0; i < x.length; i++) {
//         sum += x[i];
//     }
//     return sum;
// }

// console.log(summ(A));

// type TCvalue = {
//     cvalue: string | number | undefined | {}
// }

// interface ICvalue {
//     [key: string]: { cvalue: string | number | undefined | TCvalue } | undefined
// }

////=======================================================================================================
////=======================================================================================================

// // Напишите функцию mapObject, которая
// // в чем-то очень похожа на функцию map для массивов.

// // Эта функция должна принимать объект джаваскрипта
// // и функцию transformer, которую нужно применить к каждому из полей того объекта,
// // ...а из результата применения функции transformer к каждому полю входящего объекта
// // собрать новый объект и вернуть его.

// // Так например можно будет замэппить объект типа
// // { "roma" : 5, "vasya": 2 } оценок студентов
// // на функцию вроде (x) => x > 2
// // чтобы получить объект
// // { "roma": true, "vasya": false } зачетов студентов

// // Понятное дело для описания сигнатуры mapObject надо будет юзать
// // 1) дженерики с несколькими параметрами-типами
// // 2) такую штуку как Record (globalThis.Record, если быть точным ;) )



// type TObject = Record<string, number>;
// type TObject2 = Record<string, string | number>;
// type TResultObject = Record<string, boolean>;
// type TTransformer = (value: string | number) => boolean;


// const transformer = (value: string | number): boolean => {
//     return isNaN(Number(value)) ? Number(value) > 2 : false;
// };

// const mapObject = <T extends TObject | TObject2>(obj: T, transformer: TTransformer): TResultObject => {

//     return Object.keys(obj)
//         .reduce((acc: TResultObject, el: string) => {
//             acc[el] = transformer(obj[el])
//             return acc;
//         }, {});
// }

// const studentsRating: TObject2 = {
//     'roma': 'gggg',
//     "vasya": 2,
//     "vanya": 3,
//     "pasha": 1,
// }

// console.log(mapObject<TObject2>(studentsRating, transformer));

////=======================================================================================================
////=======================================================================================================



// Напишите функцию, которая принимает:
// 1) некие данные предполагаемо типа Т, но возможно не со всеми полями
// 2) функцию-дополнятор, которая принимает такие штуки как из п.1,
//    а возвращает полноценный объект типа Т
// ... как вы поняли, саму функцию писать не надо :)
// нас интересует только ее сигнатура.

const func = <T>(arg1: Partial<T>, arg2: (a: Partial<T>) => T): T => {
    return arg2(arg1);
}

// Более сложный вариант:
// Напишите функцию, которая принимает:
// 1) некие данные предполагаемо типа Т (у которого поле id: string),
//    но возможно без поля id
// 2) функцию-дополнятор, которая принимает такие штуки как из п.1,
//    а возвращает полноценный объект типа Т
// ... как вы поняли, саму функцию писать не надо :)
// нас интересует только ее сигнатура.

type TT = {
    id?: string;
}

const func2 = <T extends TT>(arg1: Partial<T>, arg2: (a: Partial<T>) => T): T => {
    return arg2(arg1);
}

// Последняя задача:
// Напишите сигнатуру функции, которая принимает
// - некий класс 
// - количество
// ...а возвращает массив экземпляров этого класса

class Rectangle {
    w!: number;
    h!: number;
}
class Circle {
    radius!: number;
}

// сделайте норм сигнатуру тут.
// НЕТ, Rectangle|Circle это не вариант, надо сделать универсальную функцию 
function наштамповать<T>(SOMECLASS: new () => T, count: number): T[]  {
    let a = []
    for (let i = 0; i < count; i++)
       a.push(new SOMECLASS());
   
    return a;
}

let a: Rectangle[] = наштамповать(Rectangle, 10);
let b: Circle[] = наштамповать(Circle, 20)